# 数组
### 定义： 类型 数组名[常量表达式] 
``` c
int arr[] = {1,2,3,4,5,6,7};
int* p;
p=arr;
```
* 常量表达式的定义规则
    * 不能包含变量（不允许数组长度动态定义）
    * 除主函数外，常量表达式可以从形参中取值计算得出，该情况称为“可变长数组”
* 数组名arr：数组名代表数组首元素的地址，他是一个指针常量，常量的值不会变化所以++ --失效
* 下标：arr[2] 在编译时，编译器将其转换为 *(arr+2) 来处理
* 与指针
    * “数组名”不代表整个数组，只代表首元素地址: arr == &arr[0]
    * “数组名”++、+=i、--、-=i解读为对指针的加减。
        * *(p+i): arr[i]
        * *(arr+i): arr[i]
        * arr+i: arr[i]的地址
        * arr[5]-arr[3]：结果为2，即5,3之间相差2个元素（相对距离）
        * arr[5]+arr[3]: 无意义
        * *注意！例如：p[0]=a[1],p[1]=a[4]。p[0]+1指向a[2]*
    * *p++：*先级高自右向左* 等价于 *(p++)
* 与函数
    * fun(int arr[]) 等价于 fun(int* a) 都可以接受数组
    * 在调用函数时：
        * 用变量名作为参数传递的是变量的值，不可修改原数组
        * 用数组名作为参数传递的是数组首元素地址，可修改原数组
<br>
<br>

# 二维数组

表达式|含义
-|-
a|二维数组名
a[0]; *(a+0); *a;|a[0][0]的地址
a+1; &a[1];|1行首元素的地址
a[1]; *(a+1);|a[1][0]的地址
a[1]+2; *(a+1)+2; &a[1][2];|a[1][2]的地址
\*(a[1]+2); \*(*(a+1)+2); a[1][2];|a[1][2]的值
* a指向行（行首地址）。行首地址+1指向下一行：a+2为第三行行首地址
* a[i]指向列（i行0列元素地址）。元素地址+1指向下一个元素：a[0]+2为第一行的第三列元素的地址
* 行取值（\*）指向列。因为a+1不是存储单元，找不到对应值：*(a+1)为a[0][1]的地址
* 列取地址（&）指向行。&不是地址而是找地址，找不到就把上一层给你了：&a[0]为第1行的行首地址
* 如果元素地址明确指定，是可以找到地址的，例如：&a[1][1]就是a[1][1]的地址
<br>
<br>

# 字符数组 char c[]="abcdefg";
* 定义规则
    * 定义时未进行初始化，数组中的值不可预料
    * 初值个数大于长度报错。
    * 初值个数小于长度，其余部分补\0
    * 若未指定常量表达式则初值个数为长度（不会追加\0）
* 字符串 (以\0结尾的字符数组)
    * 定义方式： 字符串"abc"
        * char c[] = {"abc"};   末尾自动补\0
        * char c[] = "abc";     末尾自动补\0
        * char c[4] = {'a', 'b', 'c', '\0'};     
        * char c[4] = {'a', 'b', 'c'};  未赋值默认为\0
    * scanf("%s", c); 不加&，因为数组名表示起始地址
``` javascript
// 以下两种方式都可以定义字符串（自动补0）
char *a="abcdef";   // 存放在常量区，意味着值不可修改
char a[]="abcdef";  // 可以修改

// 定义同长度字符串
char str[10] = "1234567890"; // 原串
char *str2 = (char *)malloc(sizeof(str)); // 定义指针数组，动态长度（char str2[n] 不可用）
str2 ="9876543210"; // 赋值
printf("%s",str2);  // 打印
```
<br>
<br>

# 指针
* 初始化： int* p1=&a;
* 取值：*
* 取地址：&
* 指针变量的加减：平移地址，平移量为当前元素的字节数

# 函数指针
``` c
int(* p)(int,int);  // p是一个指向函数的指针变量，它可以指向函数的类型为两个整型参数的函数
p = function;       // 指向函数的入口地址
(* p)(a,b);         // 调用
void fun1(int(* p)(int,int)) // 将函数指针当作参数，用法同上
```

# 返回指针的函数
``` c
float * fun((*pointer)[4], int n);  // 定义。第一个参数可以接二维数组
float *p;
p = fun({{},{}},2);                 // 调用
```

# 指针数组
``` c
int *p[3]={"one book","second book","more"};  //[]的优先级高
p[0];
p[1];
```
* 常用于指向若干个字符串（字符串本身就是数组，而定义二维数组需要指定列，书名的长度无法控制）

# main函数
``` bash
 ./file.c china good
```
``` c
int main(int argc, char* argv[]){
    printf("%d",argc);  // 3
    while(argv){
        printf("%s\n",argv++);  // file.c   china  good
    }
}
```
* argc：参数数量（文件名算一个）
* argv：参数（文件名是第一个）
