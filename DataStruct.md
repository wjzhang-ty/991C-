# 数据结构
[参考](https://zhuanlan.zhihu.com/p/134092789)

## 关于数据结构👇
* 数据：是描述客观事物的符号，并且可以被计算机识别。例如：一群人打架的视频
* 数据对象：是多个数据元素组成的东西，是数据的子集。例如：人是一个数据对象。人有姓名（元素）、生日（元素）、耳朵（元素）、眼睛等。
* 数据元素：有一定意义的基本单位。例如：黑眼圈、尖耳朵、流着血的鼻子。
* 数据项：最小的数据单位。例如：眼、耳、鼻 

---

## 线性表 
定义：线性表是具有相同数据类型的n个数据元素的有限序列，除了首尾结点，每个元素都有一个前驱一个后继。

线性表是一种**逻辑结构**（对应关系），其包含：链表，顺序表（存储结构）
* 顺序表：一组地址连续的存储单元。
    * **存储密度高**。但需要预分配空间，多了浪费，少了溢出，利用率低。
    * **随机存取访问快**。下标访问，存储位置可计算。
    * **插入删除慢**。需要移动前后元素。
    * 时间复杂度：访问元素:O(1)。 插入删除:O(n)。
* 链表：结构体，指针指向下一个
    * **动态分配存储空间**。不连续，除了数据本身还需要其他空间。
    * **插入删除块**。改变前后元素指向即可。
    * **存取效率低**。从头开始一个一个的找，太慢。
    * 时间复杂度：访问元素:O(n)。 插入删除:O(1)。
> 为什么说存储结构是随机存取的？
>> 因为地址相邻，可以直接访问到指定位置的元素。例如：获取第三个元素，用arr[2]就可以得到。
### 循环链表公式（F:队头 R:队尾 M:队列长度）
* 元素个数：(R-F+M)%M
* 是否空：R=F
* 是否满：R+1%M=F
* 插入元素：F=(F+1)%M
* 删除元素：R=(R+1)%M
---

## 栈和队列
* 队列：后进后出，排队买饭。
* 栈：后进先出，回撤功能。
* 栈的应用：前、中、后缀表达式。
    * 中转前、后：a+b*c-(d+e)
        1. 按照优先级画出括号：((a+(b*c))-(d+e))
        2. 把符号移动到括号前、后：((a(bc)*)+()+)-
        3. 去括号：abc*+de+-
    * 后转中：abc*+de+-
        * 👉这个方向找符号，👈这个方向匹配数字
        * 以括号为单位匹配，匹配完记得加括号
        1. * ： (b*c)
        2. + :  ((b*c)+a)
        3. + :  ((b*c)+a)(d+e)
        4. - :  ((b*c)+a)-(d+e)
* 循环队列公式： （当前所属：[1...m]。如果是[0...m]在m后+1即可）
    * 循环队列的“队头”、“队尾”指针指向具体元素，但不低于对头在前面。
    1. 入队：rear = (rear+1) % m
    2. 出队：front = (front + 1) % m
    3. 队空：front = rear
    4. 队满：front = (rear + 1) % m
    5. 当前队列中的元素数目：n = (rear - front + m) % m
---

## 串
* "qiniu"有多少种排列组合？
    * 重启的往后放："qnuii"
    * 5*4*3 = 60
* 子串：最多n(n+1)/2+1个。
* 模式匹配
    * BP算法：
        ``` c
            for(主串){ 
                if(主串[i]==子串[j])
                    主串、子串同时后移; 
                else 
                    主串回溯，并将子串指向开头
            }
        ```
        * 时间复杂度O：(n+m)
        * 特点：性能低
    * KMP算法：
        序号|1|2|3|4|5|6|7|8|9|10|11|12
        -|-|-|-|-|-|-|-|-|-|-|-|-
        模式串|a|b|a|b|a|a|a|b|a|b|a|a
        next|**0**|**1**|1|2|3|4|2|2|3|4|5|6
        nextval|**0**|1|0|1|0|4|2|1|0|1|0|4
        * 序号默认从1开始（0也可以）粗体字是默认值
        * next：例如序号6，取[1,5]做为子串，在子串（👉）中找最大匹配项[1,3]和[3,5]都为“aba”。所以next为长度+1=4
        * nextval：将next做为下标，做为目标。
            * 例如序号5
            1. 找到序号5的那一列：next为“3” 串为“a”
            2. 将next做为下标对应到序号为"3"的那一列：next为“1” 串为“a”
            3. 如果串相同，nextval为序号“3”的next。
            4. 如果串不同，nextval为自身列的next。
---

## 数组
* 按行|列优先：
    * 行序是这个👉方向存 a[行][列]。
    * 列序是这个👇方向存  a[列][行]。
    * 计算下标：**(行数-1)*列数+当前行下标-1**
* 特殊矩阵：即有规律的矩阵，对称、上三角、下三角、对焦。
* 稀疏矩阵：垃圾的一匹。
* 压缩矩阵：对称矩阵的**压缩存储**只存下三角即可。
### 广义表：A=(B,(b,c,d),e(f,j))
* 通常将大写字母和括号包起来的表示**子表**，小写字母表示**原子**
* 表尾：是除了表头以外的所有原子和子表组成的 新的表。

---

## 二叉树
* 术语：
    1. 节点的度：子树数目
    2. 树的度：整个二叉树种最大的“结点度”
    3. 叶子结点：没有分支的结点 
* 公式：
    * 结点总数：n0+n1+n2 （总度数+1）
    * 二叉树中：n2 = n0-1
    * 度数总和：0\*n0+1\*n1+2\*n2
    * 叶子节点个数： 1+(n2-1)\*n2数量+(n3-2)\*m3数量+...
    * 非空二叉树第i层最多有：2^i-1 个结点
    * n个结点可以构成多少种不同的树？ ((2n)!)/(n!*(n+1)!)
    * n个节点的完全二叉树深度是多少？ log2(n)+1  
    * 完全二叉树的前n层节点总数=下一层节点数-1
    * 哈夫曼树： 总结点数 = 2*叶子数-1
* 二叉排序树：左子树小于根，右子树大于根（**无相同值**）  术语：ASL平均查找长度
* 哈夫曼树：（WPL最小）
    * WPL树的带权路径长度：叶子结点的带权路径长度之和（带权路径长度为：权值*长度）
    * 构造
        1. 所有的权当作一个完整的树，组成一个森林
        2. 取最小两个数组成新的树。小权放左边，大权放右边，根节点权值为两个权之和。
        3. 循环往复。**注意每次都是新的森林，存在多个子树，不能想着一条线建上去**。
    * 编码：左0右1，从上往下读即可
* [森林转树](https://www.cnblogs.com/wangwenji/p/10223888.html)：
    * 左孩子右兄弟
    1. 连接**兄弟元素**
    2. 所有父节点仅保留最左边的子节点。
    3. 顺时旋转程树的样子。
    4. 所有树一次连接到隔壁树的右子树。顺序无要求，默认👉方向
    * 树转森林： 将根节点右侧子树依次断掉。将左孩子的右子树依次断开，并连接父结点。旋转
* [平衡二叉树](https://zhuanlan.zhihu.com/p/56066942)（AVL）
    * 任意结点左右子树高度差不超过1。**不一定是完全二叉树。**
    * 平衡因子：左子树高度-右子树高度
    * 平衡因子大于1。说明右边重。左旋一下达到平衡。
* 宽度优先用队列，深度优先用栈
* [B-树](https://blog.csdn.net/li_canhui/article/details/85305147)
    1. 用前四个排序，两两分组
    2. 依次插入新元素，凑够5个把中间的升为父节点
---

## 图
* 术语
    * 边，弧：无向图的线是边，有向图的线是弧。
    * 度：线的个数。又分为出度入度。
    * 回路|环：转圈连起来的
    * 简单路径：各结点不重复的路径（环的开头和结尾重了所以不是）
    * 子图：如其名
    * 连通：
        * 无向图中任意两个顶点都是连通的，则称为**连通图**
        * 有向图中任意两个顶点能过去能回来，则称为**强连通图**
        * （强）连通分量：极大（强）连通子图
    * 生成树：连通图包含全部顶点的一个极小连通子图（所有顶点+最少边）
    * 生成森林： 非连通图所有连通分量的生成树组成的森林
    * 网：给边加了权重就是网
* 存储
    * 邻接矩阵：就是一个二维数组arr[i][j]。
        * i和j分别代表两个端点序号。
        * 两个端点相连则值为1或者权值。不相连则值为0或者无穷
        * A^3[2][5]=1表示：2到5长度为3的路径有一条
    * 邻接表：顶点表+边表
        * 顶点表：Array<Struct{点，边表指针}>
        * 边表：Link{相连点下标，下一个Link}  （与顶点表中的“点”相连）
    * 邻接矩阵和邻接表对比：矩阵稠密，表稀疏
    * [十字链表](https://blog.csdn.net/bible_reader/article/details/71214096)：顶点表+边表
        * 顶点表：Array<Struct{点，入度边表地址，出度边表地址}>
        * 边表：Link{出发点下标，到达点下标，入度边表地址，出度边表地址，权值（可省）}
        1. 先把邻接表画出来
        2. 然后把图上所有的线连起来，入左出右。
* 遍历：
    * 广度优先(BFS)：类似于树的层次遍历，需要借助额外的数组来标记当前结点已被访问。
        * 效率：空间复杂度：O(v) 。 其中V是结点个数
            * 对于邻接矩阵：时间复杂度O(V^2)
            * 对于邻接表：时间复杂度O(V+E)
    * 深度优先(DFS)：类似于树的先序遍历，需要借助额外的数组来标记当前结点已被访问。
        * 效率：空间复杂度：O(v) 。 其中V是结点个数
            * 对于邻接矩阵：时间复杂度O(V^2)
            * 对于邻接表：时间复杂度O(V+E)
* 最小生成树
    * 克鲁斯卡尔（Kruskal）：
        1. 将路径放到一个新数组中，排序
        2. 依次将路径取出放回对应位置
        3. 检查是否有环，有环舍弃该边，无环将计数器+1。当计数器=节点数-1时完成。
    * 普林（Prim）：
        1. 三个数组：selected 记录该节点是否被选。 minDist 记录当前节点最短路径。 parent 记录当前节点与之相连的节点。
        2. 选取一个结点做为一块**区域**，与其他点所组成的区域作比较。
        3. 如果对面区域某个结点与当前区域某节点相连，更新三个数组。
        4. 选择最短距离连接（不需要累加前面的权值）。
        5. 将连接后的结点们组成新的区域，重复步骤2。
* 最短路径
    * 迪杰斯特拉（Dijkstra）：
        * 和普林算法很相似。
        * 区别：Dist数组记录距离，是累加出来的（为上一节点Dist值+当前权重）
    * 弗洛伊德（Floyd）：
        * 两个矩阵：最短路径、顶点（行点到列点，值为下一中间点，竖着查）
        * 判断过程本质是看途中两个结点的最短路径是否经过结点
        1. 将路径写入“路径数组”（行列相同不判断）。顶点数组{{0,0,0},{1,1,1},{2,2,2}}
        2. 将两个数组的i行i列取出
        3. 判断两个结点的最短路径，更新两个数组。 判断最短方法：**要么直接相连，要过经过i结点**
* AOV网
    * 顶点表示活动，有向边表示课程的先导关系。
    * AOV网是有向无环图，即不应该带有回路，因为若带有回路，则会陷入死循环。
    * 所有活动可排列成一个线性序列，使得每个活动的所有前驱活动都排在该活动的前面，我们把此序列叫做**[拓扑序列](https://blog.csdn.net/qq_37653144/article/details/83215196)**。只有完成了所有前驱事件后才可以进行后续事件。
    * AOV网的拓扑序列不是唯一的
* AOE网
    * 在AOV的基础上，改造为一种带权有向图，弧上的权值表示活动持续的时间。

---

## 内排序
* 插入排序
    * 简单插入排序
        * 👉遍历，拿一个变量往前循环，找到合适位置插入。（前边队列有序）**注意比较方向是👈**
        * 时间复杂度O(n^2)。 空间复杂度O(1)。 稳定。 顺序存储，链式存储。
    * 折半插入排序
        * 同简单插入排序，区别是在寻找插入位置时采用折半查找
        * 时间复杂度O(n^2)。 空间复杂度O(1)。 稳定。 顺序存储。
    * 希尔排序（增量排序）
        1. 分组：例如增量为3，则分\[1,4,7]\[2,5,8]\[3,6,9]三组，分别排序
        2. 增量减一，再分组排序。
* 交换排序
    * 冒泡排序：时间复杂度O(n^2)
    * [快速排序](https://blog.csdn.net/asdfsadfasdfsa/article/details/83009869)：挖坑填数+分而治之
        1. 三个变量分别指向：左端点，右端点，目标位置（从左边开始）
        2. 何为挖坑？目标位置就是挖的坑，👉方向依次挖坑
        3. 如何填数？👈方向找比“坑”小的。交换。👉方向找比坑大的交换。**直到遍历完所有结点**
        * 说白了就是：每次循环是在寻找“当前数字的位置”。顺便把小的放前面大的放后面。
        * **有序序列会变慢**影响跟挖坑效率。坑挖在中间比较快，而有序数列挖坑必然挖到两端。
* 选择排序
    * [简单选择排序](https://blog.csdn.net/xiaoqiu_cr/article/details/88190572)
        * 找到一个最小（大）的放前面，再从剩余队列里找最小（大）的放前面。
    * 堆排序
        * 小根堆：每个结点的关键字都不**大**于其孩子结点的关键字。l[i] < l[2i] 且 l[i] < l[2i+1]
        * 大根堆：每个结点的关键字都不**小**于其孩子结点的关键字。l[i] > l[2i] 且 l[i] > l[2i+1]
        * [构造过程](https://blog.csdn.net/zhizhengguan/article/details/106826270)
            1. 首先他是一个完全二叉树。因此从最后一个**非叶子节**点开始👈👆调整
            2. 当前否满足根节点大（小）于子节点？
                * 不满足交换。并查看被交换的子节点是否满足 2.条件   👇
                * 满足则向上递归。继续检查 2. 👆
        * 已知数组转大（小）根堆：👉依次插入完全二叉树中。每插入一个调整一下（往上换）。   
        * 排序过程：不断输出堆顶元素，并不断向下调整
        * **注意**堆不是完全二叉树，只是近似完全二叉树。
* [归并排序](https://zhuanlan.zhihu.com/p/124356219)
    1. 二分法拆分，递归拆分为单个元素为一个组。
    2. 相邻两组合并，排序。
    * **海量数据用这个**因为内存不够大需要先分块
* [基数排序](https://zhuanlan.zhihu.com/p/126116878)
    * 比较型整数排序算法。不要横着看，单个元素竖着看
    1. 将整数按位切分成不同数字，例如1520拆分为1 5 2 0
    2. 将数组中全部数字按照末尾数字大小，顺序不变，存入0 1 2 3 ...9的零时容器中（1520存入0）
    3. 0  1  2  3  ...9依次放回原数组
    4. 再按照倒数第二位数字拆分，重复2. 
    
算法|最好|平均|最坏|空间|稳定性|排序过程
-|-|-|-|-|-|-
直接插入|O(n)|O(n^2)|O(n^2)|O(1)|稳定|相邻操作
冒泡|O(n)|O(n^2)|O(n^2)|O(1)|稳定|相邻操作
简单选择|O(n^2)|O(n^2)|O(n^2)|O(1)|不稳定|相邻操作
希尔|数学界|证明|不出来|O(1)|不稳定|非相邻
快速|O(Nlog2N)|O(Nlog2N)|O(n^2)|O(log2N)|不稳定|相邻操作
堆|O(Nlog2N)|O(Nlog2N)|O(Nlog2N)|O(1)|不稳定|非相邻
二路归并|O(Nlog2N)|O(Nlog2N)|O(Nlog2N)|O(n)|稳定|非相邻
基数|O(d(n+r))|O(d(n+r))|O(d(n+r))|O(r)|稳定|非相邻

> 稳定性也可以理解为“精俭排序”，即一对数字不进行两次和两次以上的比较



